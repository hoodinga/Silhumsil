<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D ê³µê°„ ë„í˜• ê²½ë¡œ ìµœì í™”</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2em;
            margin-bottom: 10px;
        }
        
        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }
        
        .content {
            display: grid;
            grid-template-columns: 300px 1fr 350px;
            gap: 20px;
            padding: 30px;
        }
        
        .control-panel {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 12px;
            max-height: 800px;
            overflow-y: auto;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #333;
        }
        
        .control-group select,
        .control-group input[type="range"],
        .control-group input[type="number"] {
            width: 100%;
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }
        
        .control-group input[type="range"] {
            padding: 0;
        }
        
        .value-display {
            text-align: right;
            color: #667eea;
            font-weight: 600;
            margin-top: 5px;
        }
        
        button {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 10px;
            transition: transform 0.2s;
        }
        
        button:hover {
            transform: translateY(-2px);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .canvas-container {
            position: relative;
            background: #1a1a1a;
            border-radius: 12px;
            border: 2px solid #e0e0e0;
            overflow: hidden;
            height: 700px;
        }
        
        #canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .stats-panel {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 12px;
            max-height: 800px;
            overflow-y: auto;
        }
        
        .stat-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 4px solid #667eea;
        }
        
        .stat-card h3 {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .stat-value {
            font-size: 1.8em;
            font-weight: 700;
            color: #333;
        }
        
        .stat-unit {
            font-size: 0.9em;
            color: #999;
            margin-left: 5px;
        }
        
        .gcode-preview {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
            line-height: 1.6;
        }
        
        .gcode-comment {
            color: #6a9955;
        }
        
        .gcode-command {
            color: #4ec9b0;
        }
        
        .legend {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s;
        }
        
        @media (max-width: 1200px) {
            .content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¨ 3D ê³µê°„ ë„í˜• ê²½ë¡œ ìµœì í™”</h1>
            <p>3D í”„ë¦°íŒ…ì„ ìœ„í•œ ê³µê°„ ê³¡ë©´ ê²½ë¡œ ìƒì„± ë° ìµœì í™”</p>
        </div>
        
        <div class="content">
            <div class="control-panel">
                <h2 style="margin-bottom: 20px; color: #333;">ì œì–´ íŒ¨ë„</h2>
                
                <div class="control-group">
                    <label>ë„í˜• íƒ€ì…</label>
                    <select id="shapeType">
                        <option value="sphere">êµ¬ (Sphere)</option>
                        <option value="cylinder">ì›ê¸°ë‘¥ (Cylinder)</option>
                        <option value="torus" selected>í† ëŸ¬ìŠ¤ (Torus)</option>
                        <option value="helix">í—¬ë¦­ìŠ¤ (Helix)</option>
                        <option value="cone">ì›ë¿” (Cone)</option>
                        <option value="spiral">êµ¬ë©´ ë‚˜ì„  (Spherical Spiral)</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label>ê²½ë¡œ íŒ¨í„´</label>
                    <select id="pathPattern">
                        <option value="spiral">ë‚˜ì„ í˜•</option>
                        <option value="zigzag">ì§€ê·¸ì¬ê·¸</option>
                        <option value="concentric">ë™ì‹¬ì›</option>
                        <option value="hilbert">íë² ë¥´íŠ¸ ê³¡ì„ </option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label>ë ˆì´ì–´ ìˆ˜</label>
                    <input type="range" id="layers" min="5" max="100" step="5" value="30">
                    <div class="value-display"><span id="layersValue">30</span> ì¸µ</div>
                </div>
                
                <div class="control-group">
                    <label>ë ˆì´ì–´ë‹¹ ì„¸ê·¸ë¨¼íŠ¸</label>
                    <input type="range" id="segments" min="10" max="100" step="5" value="40">
                    <div class="value-display"><span id="segmentsValue">40</span> ê°œ</div>
                </div>
                
                <div class="control-group">
                    <label>ë„í˜• í¬ê¸°</label>
                    <input type="range" id="size" min="0.5" max="3" step="0.1" value="1.5">
                    <div class="value-display"><span id="sizeValue">1.5</span> ë°°</div>
                </div>
                
                <div class="control-group">
                    <label>ë…¸ì¦ ì§€ë¦„</label>
                    <input type="number" id="nozzle" min="0.1" max="1.0" step="0.1" value="0.4">
                    <div class="value-display">mm</div>
                </div>
                
                <div class="control-group">
                    <label>ë ˆì´ì–´ ë†’ì´</label>
                    <input type="number" id="layerHeight" min="0.05" max="0.4" step="0.05" value="0.2">
                    <div class="value-display">mm</div>
                </div>
                
                <button onclick="generatePath()">ğŸ”„ ê²½ë¡œ ì¬ìƒì„±</button>
                <button onclick="startAnimation()">â–¶ï¸ ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘</button>
                <button onclick="stopAnimation()">â¸ï¸ ì •ì§€</button>
                <button onclick="resetView()">ğŸ¯ ë·° ë¦¬ì…‹</button>
                <button onclick="downloadGCode()">ğŸ’¾ G-code ë‹¤ìš´ë¡œë“œ</button>
                
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #4CAF50;"></div>
                        <span>ì‹œì‘ì </span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #FF5722;"></div>
                        <span>ì¢…ë£Œì </span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #2196F3;"></div>
                        <span>í”„ë¦°íŒ… ê²½ë¡œ</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: rgba(255,255,255,0.3);"></div>
                        <span>ë„í˜• í‘œë©´</span>
                    </div>
                </div>
            </div>
            
            <div class="canvas-container">
                <canvas id="canvas"></canvas>
            </div>
            
            <div class="stats-panel">
                <h2 style="margin-bottom: 20px; color: #333;">í†µê³„</h2>
                
                <div class="stat-card">
                    <h3>ì´ ê²½ë¡œ ê¸¸ì´</h3>
                    <div class="stat-value" id="pathLength">0<span class="stat-unit">mm</span></div>
                </div>
                
                <div class="stat-card">
                    <h3>í”„ë¦°íŒ… ì‹œê°„ (ì˜ˆìƒ)</h3>
                    <div class="stat-value" id="printTime">0<span class="stat-unit">ë¶„</span></div>
                </div>
                
                <div class="stat-card">
                    <h3>ì´ í¬ì¸íŠ¸ ìˆ˜</h3>
                    <div class="stat-value" id="pointCount">0<span class="stat-unit">ê°œ</span></div>
                </div>
                
                <div class="stat-card">
                    <h3>í•„ë¼ë©˜íŠ¸ ì†Œìš”ëŸ‰</h3>
                    <div class="stat-value" id="filament">0<span class="stat-unit">mmÂ³</span></div>
                </div>
                
                <div class="stat-card">
                    <h3>í•„ë¼ë©˜íŠ¸ ë¬´ê²Œ</h3>
                    <div class="stat-value" id="filamentWeight">0<span class="stat-unit">g</span></div>
                </div>
                
                <div class="stat-card">
                    <h3>í‘œë©´ì </h3>
                    <div class="stat-value" id="surfaceArea">0<span class="stat-unit">mmÂ²</span></div>
                </div>
                
                <h3 style="margin: 20px 0 10px; color: #333;">G-code ë¯¸ë¦¬ë³´ê¸°</h3>
                <div class="gcode-preview" id="gcodePreview">
                    <span class="gcode-comment">; G-code will appear here</span>
                </div>
                
                <div class="progress-bar">
                    <div class="progress-fill" id="progress" style="width: 0%"></div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, controls;
        let shapeMesh, pathLine, startPoint, endPoint;
        let pathPoints = [];
        let animationId = null;
        let animationProgress = 0;
        let currentGCode = [];
        
        // Initialize Three.js scene
        function initScene() {
            const container = document.getElementById('canvas');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            
            camera = new THREE.PerspectiveCamera(
                75,
                container.offsetWidth / container.offsetHeight,
                0.1,
                1000
            );
            camera.position.set(5, 5, 5);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ canvas: container, antialias: true });
            renderer.setSize(container.offsetWidth, container.offsetHeight);
            
            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            scene.add(directionalLight);
            
            // Grid helper
            const gridHelper = new THREE.GridHelper(10, 10, 0x444444, 0x222222);
            scene.add(gridHelper);
            
            // Axes helper
            const axesHelper = new THREE.AxesHelper(3);
            scene.add(axesHelper);
            
            // Mouse controls (manual implementation)
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            
            container.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });
            
            container.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;
                    
                    const rotationSpeed = 0.005;
                    
                    const quaternion = new THREE.Quaternion();
                    quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), deltaX * rotationSpeed);
                    camera.position.applyQuaternion(quaternion);
                    
                    const right = new THREE.Vector3();
                    camera.getWorldDirection(right);
                    right.cross(camera.up).normalize();
                    quaternion.setFromAxisAngle(right, deltaY * rotationSpeed);
                    camera.position.applyQuaternion(quaternion);
                    
                    camera.lookAt(0, 0, 0);
                    
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });
            
            container.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoomSpeed = 0.1;
                const direction = camera.position.clone().normalize();
                camera.position.addScaledVector(direction, e.deltaY * zoomSpeed * 0.01);
            });
            
            generatePath();
            animate();
        }
        
        // Generate shape geometry
        function getShapeGeometry() {
            const shapeType = document.getElementById('shapeType').value;
            const size = parseFloat(document.getElementById('size').value);
            
            let geometry;
            switch (shapeType) {
                case 'sphere':
                    geometry = new THREE.SphereGeometry(2 * size, 32, 32);
                    break;
                case 'cylinder':
                    geometry = new THREE.CylinderGeometry(1.5 * size, 1.5 * size, 4 * size, 32);
                    break;
                case 'torus':
                    geometry = new THREE.TorusGeometry(2 * size, 0.8 * size, 16, 100);
                    break;
                case 'cone':
                    geometry = new THREE.ConeGeometry(2 * size, 4 * size, 32);
                    break;
                default:
                    geometry = new THREE.TorusGeometry(2 * size, 0.8 * size, 16, 100);
            }
            return geometry;
        }
        
        // Generate path based on shape and pattern
        function generatePath() {
            // Remove old objects
            if (shapeMesh) scene.remove(shapeMesh);
            if (pathLine) scene.remove(pathLine);
            if (startPoint) scene.remove(startPoint);
            if (endPoint) scene.remove(endPoint);
            
            const shapeType = document.getElementById('shapeType').value;
            const pathPattern = document.getElementById('pathPattern').value;
            const layers = parseInt(document.getElementById('layers').value);
            const segments = parseInt(document.getElementById('segments').value);
            const size = parseFloat(document.getElementById('size').value);
            
            // Create shape mesh
            const geometry = getShapeGeometry();
            const material = new THREE.MeshPhongMaterial({
                color: 0x888888,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            shapeMesh = new THREE.Mesh(geometry, material);
            scene.add(shapeMesh);
            
            // Generate path points
            pathPoints = generatePathPoints(shapeType, pathPattern, layers, segments, size);
            
            // Create path line
            const lineGeometry = new THREE.BufferGeometry().setFromPoints(pathPoints);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x2196F3, linewidth: 2 });
            pathLine = new THREE.Line(lineGeometry, lineMaterial);
            scene.add(pathLine);
            
            // Add start and end points
            if (pathPoints.length > 0) {
                const sphereGeometry = new THREE.SphereGeometry(0.1, 16, 16);
                
                const startMaterial = new THREE.MeshBasicMaterial({ color: 0x4CAF50 });
                startPoint = new THREE.Mesh(sphereGeometry, startMaterial);
                startPoint.position.copy(pathPoints[0]);
                scene.add(startPoint);
                
                const endMaterial = new THREE.MeshBasicMaterial({ color: 0xFF5722 });
                endPoint = new THREE.Mesh(sphereGeometry, endMaterial);
                endPoint.position.copy(pathPoints[pathPoints.length - 1]);
                scene.add(endPoint);
            }
            
            updateStatistics();
            generateGCode();
        }
        
        // Generate path points based on shape and pattern
        function generatePathPoints(shapeType, pathPattern, layers, segments, size) {
            const points = [];
            
            if (shapeType === 'sphere') {
                for (let i = 0; i < layers; i++) {
                    const phi = (i / (layers - 1)) * Math.PI;
                    const radius = Math.sin(phi) * 2 * size;
                    const y = Math.cos(phi) * 2 * size;
                    
                    for (let j = 0; j < segments; j++) {
                        const theta = (j / segments) * Math.PI * 2;
                        const x = radius * Math.cos(theta);
                        const z = radius * Math.sin(theta);
                        points.push(new THREE.Vector3(x, y, z));
                    }
                }
            } else if (shapeType === 'cylinder') {
                const radius = 1.5 * size;
                const height = 4 * size;
                
                for (let i = 0; i < layers; i++) {
                    const y = -height / 2 + (i / (layers - 1)) * height;
                    
                    for (let j = 0; j < segments; j++) {
                        const theta = (j / segments) * Math.PI * 2;
                        const x = radius * Math.cos(theta);
                        const z = radius * Math.sin(theta);
                        points.push(new THREE.Vector3(x, y, z));
                    }
                }
            } else if (shapeType === 'torus') {
                const R = 2 * size;
                const r = 0.8 * size;
                
                for (let i = 0; i < layers; i++) {
                    const v = (i / (layers - 1)) * Math.PI * 2;
                    
                    for (let j = 0; j < segments; j++) {
                        const u = (j / segments) * Math.PI * 2;
                        const x = (R + r * Math.cos(v)) * Math.cos(u);
                        const y = r * Math.sin(v);
                        const z = (R + r * Math.cos(v)) * Math.sin(u);
                        points.push(new THREE.Vector3(x, y, z));
                    }
                }
            } else if (shapeType === 'helix') {
                const radius = 2 * size;
                const height = 4 * size;
                const turns = 5;
                
                for (let i = 0; i < layers * segments; i++) {
                    const t = i / (layers * segments);
                    const theta = t * Math.PI * 2 * turns;
                    const x = radius * Math.cos(theta);
                    const y = -height / 2 + t * height;
                    const z = radius * Math.sin(theta);
                    points.push(new THREE.Vector3(x, y, z));
                }
            } else if (shapeType === 'cone') {
                const baseRadius = 2 * size;
                const height = 4 * size;
                
                for (let i = 0; i < layers; i++) {
                    const y = -height / 2 + (i / (layers - 1)) * height;
                    const radius = baseRadius * (1 - i / (layers - 1));
                    
                    for (let j = 0; j < segments; j++) {
                        const theta = (j / segments) * Math.PI * 2;
                        const x = radius * Math.cos(theta);
                        const z = radius * Math.sin(theta);
                        points.push(new THREE.Vector3(x, y, z));
                    }
                }
            } else if (shapeType === 'spiral') {
                const radius = 2 * size;
                const turns = 10;
                
                for (let i = 0; i < layers * segments; i++) {
                    const t = i / (layers * segments);
                    const phi = t * Math.PI;
                    const theta = t * Math.PI * 2 * turns;
                    
                    const r = Math.sin(phi) * radius;
                    const x = r * Math.cos(theta);
                    const y = Math.cos(phi) * radius;
                    const z = r * Math.sin(theta);
                    points.push(new THREE.Vector3(x, y, z));
                }
            }
            
            return points;
        }
        
        // Update statistics
        function updateStatistics() {
            let totalLength = 0;
            for (let i = 1; i < pathPoints.length; i++) {
                totalLength += pathPoints[i].distanceTo(pathPoints[i - 1]);
            }
            
            const nozzle = parseFloat(document.getElementById('nozzle').value);
            const layerHeight = parseFloat(document.getElementById('layerHeight').value);
            
            const filamentVolume = totalLength * Math.PI * (nozzle / 2) ** 2;
            const filamentWeight = filamentVolume * 0.00125; // PLA density: 1.25 g/cmÂ³
            
            const printSpeed = 50; // mm/s
            const printTime = (totalLength / printSpeed) / 60; // minutes
            
            const surfaceArea = calculateSurfaceArea();
            
            document.getElementById('pathLength').innerHTML = totalLength.toFixed(2) + '<span class="stat-unit">mm</span>';
            document.getElementById('printTime').innerHTML = printTime.toFixed(1) + '<span class="stat-unit">ë¶„</span>';
            document.getElementById('pointCount').innerHTML = pathPoints.length + '<span class="stat-unit">ê°œ</span>';
            document.getElementById('filament').innerHTML = filamentVolume.toFixed(2) + '<span class="stat-unit">mmÂ³</span>';
            document.getElementById('filamentWeight').innerHTML = filamentWeight.toFixed(2) + '<span class="stat-unit">g</span>';
            document.getElementById('surfaceArea').innerHTML = surfaceArea.toFixed(2) + '<span class="stat-unit">mmÂ²</span>';
        }
        
        // Calculate surface area
        function calculateSurfaceArea() {
            const shapeType = document.getElementById('shapeType').value;
            const size = parseFloat(document.getElementById('size').value);
            
            let area = 0;
            switch (shapeType) {
                case 'sphere':
                    area = 4 * Math.PI * (2 * size) ** 2;
                    break;
                case 'cylinder':
                    const r = 1.5 * size;
                    const h = 4 * size;
                    area = 2 * Math.PI * r * h + 2 * Math.PI * r ** 2;
                    break;
                case 'torus':
                    const R = 2 * size;
                    const r2 = 0.8 * size;
                    area = 4 * Math.PI ** 2 * R * r2;
                    break;
                case 'cone':
                    const base = 2 * size;
                    const height = 4 * size;
                    const slant = Math.sqrt(base ** 2 + height ** 2);
                    area = Math.PI * base * slant + Math.PI * base ** 2;
                    break;
                default:
                    area = 0;
            }
            return area;
        }
        
        // Generate G-code
        function generateGCode() {
            const nozzle = parseFloat(document.getElementById('nozzle').value);
            const layerHeight = parseFloat(document.getElementById('layerHeight').value);
            
            currentGCode = [];
            currentGCode.push('; Generated by 3D Path Optimizer');
            currentGCode.push('; Date: ' + new Date().toLocaleString());
            currentGCode.push('; Shape: ' + document.getElementById('shapeType').value);
            currentGCode.push('G28 ; Home all axes');
            currentGCode.push('G1 Z' + layerHeight.toFixed(3) + ' F300');
            currentGCode.push('M109 S200 ; Set hotend temperature');
            currentGCode.push('G92 E0 ; Reset extruder');
            currentGCode.push('');
            
            let e = 0;
            for (let i = 0; i < pathPoints.length; i++) {
                const p = pathPoints[i];
                const x = p.x.toFixed(3);
                const y = p.z.toFixed(3);
                const z = p.y.toFixed(3);
                
                if (i > 0) {
                    const dist = pathPoints[i].distanceTo(pathPoints[i - 1]);
                    e += dist * 0.04;
                }
                
                currentGCode.push(`G1 X${x} Y${y} Z${z} E${e.toFixed(4)} F1500`);
            }
            
            currentGCode.push('');
            currentGCode.push('G92 E0 ; Reset extruder');
            currentGCode.push('M104 S0 ; Turn off hotend');
            currentGCode.push('M140 S0 ; Turn off bed');
            currentGCode.push('G28 X Y ; Home X and Y');
            currentGCode.push('M84 ; Disable motors');
            
            // Display preview
            const preview = currentGCode.slice(0, 20).map(line => {
                if (line.startsWith(';')) {
                    return `<span class="gcode-comment">${line}</span>`;
                } else if (line.startsWith('G') || line.startsWith('M')) {
                    return `<span class="gcode-command">${line}</span>`;
                }
                return line;
            }).join('\n');
            
            document.getElementById('gcodePreview').innerHTML = preview + 
                '\n<span class="gcode-comment">; ... (ì´ ' + currentGCode.length + 'ì¤„)</span>';
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        
        // Start animation
        function startAnimation() {
            stopAnimation();
            animationProgress = 0;
            
            function animatePath() {
                animationProgress += 0.002;
                if (animationProgress > 1) animationProgress = 1;
                
                // Update path line
                const visiblePoints = Math.floor(pathPoints.length * animationProgress);
                const lineGeometry = new THREE.BufferGeometry().setFromPoints(
                    pathPoints.slice(0, visiblePoints)
                );
                
                if (pathLine) {
                    scene.remove(pathLine);
                }
                
                const lineMaterial = new THREE.LineBasicMaterial({ 
                    color: 0x2196F3, 
                    linewidth: 2 
                });
                pathLine = new THREE.Line(lineGeometry, lineMaterial);
                scene.add(pathLine);
                
                document.getElementById('progress').style.width = (animationProgress * 100) + '%';
                
                if (animationProgress < 1) {
                    animationId = requestAnimationFrame(animatePath);
                } else {
                    // Re-add end point
                    if (endPoint) {
                        scene.add(endPoint);
                    }
                }
            }
            
            // Hide end point during animation
            if (endPoint) {
                scene.remove(endPoint);
            }
            
            animatePath();
        }
        
        // Stop animation
        function stopAnimation() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            animationProgress = 0;
            document.getElementById('progress').style.width = '0%';
            
            // Restore full path
            if (pathPoints.length > 0) {
                const lineGeometry = new THREE.BufferGeometry().setFromPoints(pathPoints);
                
                if (pathLine) {
                    scene.remove(pathLine);
                }
                
                const lineMaterial = new THREE.LineBasicMaterial({ 
                    color: 0x2196F3, 
                    linewidth: 2 
                });
                pathLine = new THREE.Line(lineGeometry, lineMaterial);
                scene.add(pathLine);
                
                // Re-add end point
                if (endPoint && !scene.children.includes(endPoint)) {
                    scene.add(endPoint);
                }
            }
        }
        
        // Reset camera view
        function resetView() {
            camera.position.set(5, 5, 5);
            camera.lookAt(0, 0, 0);
        }
        
        // Download G-code
        function downloadGCode() {
            if (currentGCode.length === 0) return;
            
            const blob = new Blob([currentGCode.join('\n')], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = '3d_path_' + document.getElementById('shapeType').value + '.gcode';
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // Event listeners
        document.getElementById('shapeType').addEventListener('change', generatePath);
        document.getElementById('pathPattern').addEventListener('change', generatePath);
        
        document.getElementById('layers').addEventListener('input', (e) => {
            document.getElementById('layersValue').textContent = e.target.value;
            generatePath();
        });
        
        document.getElementById('segments').addEventListener('input', (e) => {
            document.getElementById('segmentsValue').textContent = e.target.value;
            generatePath();
        });
        
        document.getElementById('size').addEventListener('input', (e) => {
            document.getElementById('sizeValue').textContent = e.target.value;
            generatePath();
        });
        
        document.getElementById('nozzle').addEventListener('input', () => {
            updateStatistics();
            generateGCode();
        });
        
        document.getElementById('layerHeight').addEventListener('input', () => {
            updateStatistics();
            generateGCode();
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            const container = document.getElementById('canvas');
            camera.aspect = container.offsetWidth / container.offsetHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.offsetWidth, container.offsetHeight);
        });
        
        // Initialize on load
        window.addEventListener('load', initScene);
    </script>
</body>
</html>
            